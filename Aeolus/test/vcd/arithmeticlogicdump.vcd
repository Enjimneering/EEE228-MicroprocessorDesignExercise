$date
	Fri Feb 21 11:23:48 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1ns
$end
$scope module ALUTb $end
$var wire 1 ! OVERFLOW $end
$var wire 4 " ALU_OUT [3:0] $end
$var reg 1 # CLK $end
$var reg 4 $ IN1 [3:0] $end
$var reg 4 % IN2 [3:0] $end
$var reg 9 & OPCODE [8:0] $end
$var reg 1 ' RESET $end
$scope module alu $end
$var wire 1 ( ADD $end
$var wire 1 ) AND $end
$var wire 1 * CLR $end
$var wire 1 + INV $end
$var wire 1 , LSH $end
$var wire 1 - LSR $end
$var wire 1 . OR $end
$var wire 1 / RSH $end
$var wire 1 0 SUB $end
$var wire 1 1 XOR $end
$var wire 1 # clk $end
$var wire 4 2 in1 [3:0] $end
$var wire 4 3 in2 [3:0] $end
$var wire 1 ' reset $end
$var wire 4 4 xorOut [3:0] $end
$var wire 1 5 subtractorOverflowFlag $end
$var wire 4 6 subtractorOut [3:0] $end
$var wire 4 7 shiftOut [3:0] $end
$var wire 1 8 shiftFlag $end
$var wire 4 9 orOut [3:0] $end
$var wire 4 : notOut [3:0] $end
$var wire 4 ; andOut [3:0] $end
$var wire 1 < adderOverflowFlag $end
$var wire 4 = adderOut [3:0] $end
$var reg 4 > out [3:0] $end
$var reg 1 ! overflow $end
$scope module adder $end
$var wire 4 ? in1 [3:0] $end
$var wire 4 @ in2 [3:0] $end
$var reg 4 A out [3:0] $end
$var reg 1 < overflow $end
$upscope $end
$scope module andGate $end
$var wire 4 B in1 [3:0] $end
$var wire 4 C in2 [3:0] $end
$var wire 4 D out [3:0] $end
$upscope $end
$scope module notGate $end
$var wire 4 E in1 [3:0] $end
$var wire 4 F out [3:0] $end
$upscope $end
$scope module orGate $end
$var wire 4 G in1 [3:0] $end
$var wire 4 H in2 [3:0] $end
$var wire 4 I out [3:0] $end
$upscope $end
$scope module sr $end
$var wire 1 # clk $end
$var wire 4 J in [3:0] $end
$var wire 1 - loadEnable $end
$var wire 2 K shiftState [1:0] $end
$var wire 4 L dataReg [3:0] $end
$var reg 1 8 flag $end
$var reg 4 M out [3:0] $end
$scope module inShift $end
$var wire 4 N D [3:0] $end
$var wire 1 # clk $end
$var wire 1 - enable $end
$var reg 4 O Q [3:0] $end
$upscope $end
$upscope $end
$scope module subtractor $end
$var wire 4 P in1 [3:0] $end
$var wire 4 Q in2 [3:0] $end
$var reg 4 R out [3:0] $end
$var reg 1 5 overflow $end
$upscope $end
$scope module xorGate $end
$var wire 4 S in1 [3:0] $end
$var wire 4 T in2 [3:0] $end
$var wire 4 U out [3:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b10 U
b101 T
b111 S
b10 R
b101 Q
b111 P
bx O
b111 N
b0 M
bx L
b0 K
b111 J
b111 I
b101 H
b111 G
b1000 F
b111 E
b101 D
b101 C
b111 B
b1100 A
b101 @
b111 ?
bx >
b1100 =
0<
b101 ;
b1000 :
b111 9
x8
b0 7
b10 6
05
b10 4
b101 3
b111 2
01
00
0/
0.
0-
0,
0+
z*
0)
0(
x'
b0 &
b101 %
b111 $
1#
bx "
x!
$end
#5
0#
#10
1#
#15
0!
b1100 "
b1100 >
1(
0#
b1 &
#20
1#
#25
0#
#30
b10 "
b10 >
0(
10
1#
b10 &
#35
0#
#40
1#
#45
0#
#50
b111 L
b111 O
00
1-
1#
b100 &
#55
0#
#60
1#
#65
0#
#70
b1110 "
b1110 >
08
b1110 7
b1110 M
0-
b10 K
1,
1#
b1000 &
#75
0#
#80
1#
#85
0#
#90
b11 "
b11 >
b11 7
b11 M
0,
b1 K
1/
1#
b10000 &
#95
0#
#100
1#
#105
0#
#110
b0 7
b0 M
b101 "
b101 >
b0 K
0/
1)
1#
b100000 &
#115
0#
#120
1#
#125
0#
#130
b111 "
b111 >
0)
1.
1#
b1000000 &
#135
0#
#140
1#
#145
0#
#150
b10 "
b10 >
0.
11
1#
b10000000 &
#155
0#
#160
1#
#165
0#
#170
b1000 "
b1000 >
01
1+
1#
b100000000 &
#175
0#
#180
1#
#185
0#
